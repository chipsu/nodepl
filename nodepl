#!/usr/bin/python
#
# TODO: Optimize remote commands
# TODO: Custom public key
# TODO: Remote user option
# TODO: Triggers
# TODO: Just add to authorized_keys, dont overwrite
# TODO: Some config files should be uploaded before first apt-get upgrade
#

import os, sys, commands, subprocess
from os.path import expanduser


def ssh_exec(host, command):
    return sys_exec(['ssh', host, command])

def rsync(src, dst, options):
    #sending incremental file list

    return sys_exec(['rsync'] + options + [src, dst])

class nodepl:
    stdout = None
    stderr = None
    returncode = None

    def test(self):
        self.log('ttesting')
        return self.shell(['ls', '/', '-lh'])

    def log(self, message):
        print message

    def shell(self, command, silent=False):
        try:
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.stdout, self.stderr = process.communicate()
            self.returncode = process.returncode
            if self.returncode == 0:
                return True
            if not silent:
                self.log('error: ' + str(self.returncode))
                self.log(self.stderr)
            return False
        except Exception, ex:
            print 'exception', ex
            return False

class nodepl_package(nodepl):
    command = ['apt-get', '-y', '-o', 'Dpkg::Options::="--force-confdef"', '-o', 'Dpkg::Options::="--force-confold"']

    def has(self, package):
        return self.shell(['dpkg', '-s', package], silent=True)

    def install(self, package):
        if not self.has(package):
            self.log('++ Installing package: ' + package)
            return self.shell(self.command + [package, 'install'])
        return None

    def remove(self, package):
        if self.has(package):
            self.log('-- Removing package: ' + package)
            return self.shell(self.command + [package, 'remove'])
        return None

    def upgrade(self):
        self.log('** Upgrading packages')
        return self.shell(self.command + ['update']) and self.shell(self.command + ['dist-upgrade'])

    def add_key(self, keyfile, id):
        #if(!sys_exec(['apt-key', 'list', '|', 'grep', id])):
        #    sys_exec(['wget', '-O/tmp/dotdeb.gpg', 'http://www.dotdeb.org/dotdeb.gpg', && apt-key add /tmp/dotdeb.gpg && 
        pass

nodepl = nodepl_package()
print nodepl.has('nginx')
print nodepl.upgrade()

exit(1)

#execfile(sys.argv[1])


public_key_file = open(expanduser("~") + '/.ssh/id_rsa.pub', 'r')
public_key = public_key_file.read()
public_key_file.close()

init_script_template = """
if [[ ! -f ~/.ssh/id_rsa ]]; then
    ssh-keygen;
fi;

if ! type rsync; then
    apt-get install rsync -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold";
fi;

echo '{public_key}' > ~/.ssh/authorized_keys
chmod u=rw,o=,g= ~/.ssh/id_rsa.pub

"""

for node_name in nodes:
    node = nodes[node_name]
    host = 'host' in node and node['host'] or node_name
    ssh_host = 'root@' + host
    print 'sync node:', ssh_host, '(' + node_name + ')'
    print '    roles:', node['roles']
    packages = {}
    services = {}
    filesystems = {}
    for role_name in node['roles']:
        role = roles[role_name]
        if 'packages' in role:
            packages.update(role['packages'])
        if 'services' in role:
            services.update(role['services'])
        if 'filesystems' in role:
            filesystems.update(role['filesystems'])
    remote_commands = []
    package_commands = []
    service_commands = []
    remote_commands.append(init_script_template.format(public_key = public_key))
    for name in packages:
        package = isinstance(packages[name], basestring) and {'status': packages[name]} or packages[name]
        print '        package:', name, package['status']
        package_commands.append('apt-get ' + package['status'] + ' ' + name + ' -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold"')
    for name in services:
        service = isinstance(services[name], basestring) and {'status': services[name]} or services[name]
        print '        service:', name, service['status']
        service_commands.append('service ' + name + ' ' + service['status'])
    print '    execute remote commands'
    ssh_exec(ssh_host, "\n".join(remote_commands + package_commands + service_commands))
    print '    syncing files...'
    for name in filesystems:
        filesystem = isinstance(filesystems[name], basestring) and {'path': filesystems[name]} or filesystems[name]
        path = filesystem['path']
        source = 'source' in filesystem and filesystem['source'] or path
        if os.path.isdir(source) and not source.endswith('/'):
            source += '/'
        options = ['-v']
        print '        filesystem:', name, path
        print '        sync:', path, 'from', source
        if 'delete' in filesystem and filesystem['delete']:
            options.append('--delete')
        if 'recursive' in filesystem and filesystem['recursive']:
            options.append('-a')
        rsync(source, ssh_host + ':' + path, options)
        if 'on_change' in filesystem and filesystem['on_change']:
            # TODO: run only if something changed...
            ssh_exec(ssh_host, filesystem['on_change'])
    # make sure services are running if they depend on any changed files...
    print '    execute remote commands'
    ssh_exec(ssh_host, "\n".join(service_commands))
