#!/usr/bin/python
#
# TODO: Config URL
# TODO: Optimize remote commands
# TODO: Custom public key
# TODO: Remote user option
# TODO: Triggers
# TODO: Just add to authorized_keys, dont overwrite
# TODO: Some config files should be uploaded before first apt-get upgrade

import os, sys, commands, subprocess, base64, errno
from os.path import expanduser

def XXssh_exec(host, command):
    return sys_exec(['ssh', host, command])

def XXrsync(src, dst, options):
    return sys_exec(['rsync'] + ['--rsh', 'ssh -c arcfour'] + options + [src, dst])

class nodepl:
    home = expanduser('~')
    stdout = None
    stderr = None
    returncode = None
    nodepl_path = '/usr/local/bin/nodepl'
    colors = {
        'debug': '\033[95m',
        'notice': '\033[94m',
        'success': '\033[92m',
        'warning': '\033[93m',
        'error': '\033[91m',
    }

    def __init__(self, options = {}):
        self.options = options

    def load_config(self, filename, defaults = {}, options_prefix = False):
        if not os.path.isfile(filename):
            print 'Config file not found: ' + filename
            exit(1)
        script_locals = {}
        execfile(filename, {}, script_locals)
        merge = defaults.copy()
        merge.update(script_locals['config'])
        config = merge
        if options_prefix:
            for key in self.options:
                if key.startswith(options_prefix):
                    config[key[len(options_prefix):]] = self.options[key]
        return config

    def array_get(self, array, key, default = False):
        return key in array and array[key] or default

    def get_option(self, key, default = False):
        return self.array_get(self.options, key, default)

    def test(self):
        self.log_notice('ttesting')
        return self.shell(['ls', '/', '-lh'])

    def log(self, level, message):
        if level in self.colors:
            message = self.colors[level] + message + '\033[0m'
        self.shell(['echo', message], popen=False)

    def log_debug(self, message):
        self.log('debug', message)

    def log_notice(self, message):
        self.log('notice', message)

    def log_success(self, message):
        self.log('success', message)

    def log_warning(self, message):
        self.log('warning', message)

    def log_error(self, message):
        self.log('error', message)

    def log_failed_command(self, command):
        logfile = '/tmp/nodepl-command.log'
        with open(logfile, 'a') as handle:
            handle.write("\n--- ".join(command))
        self.log_error('see ' + logfile + ' for details')

    def shell(self, command, silent=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, popen=True):
        try:
            if popen:
                process = subprocess.Popen(command, stdout=stdout, stderr=stderr)
                self.stdout, self.stderr = process.communicate()
                self.returncode = process.returncode
            else:
                self.returncode = subprocess.call(command)
            if self.returncode == 0:
                return True
            if not silent:
                self.log_error('Error: Code=' + str(self.returncode) + ", popen=" + str(popen))
                self.log_failed_command(command)
                if self.stderr != None:
                    self.log_error(self.stderr)
                else:
                    self.log_error('stderr empty')
            return False
        except Exception, ex:
            self.log_local('error', 'exception: ' + str(ex))
            self.log_failed_command(command)
            return False

    def remote_shell(self, host, command, silent=False):
        command = command.format(nodepl=self.nodepl_path)
        return self.shell(['ssh', '-t', host, command], silent=silent, popen=False)

    def rsync(self, src, dst, options):
        return self.shell(['rsync'] + ['--rsh', 'ssh -c arcfour'] + options + [src, dst], popen=False)

    def log_local(self, level, message):
        if level in self.colors:
            message = self.colors[level] + message + '\033[0m'
        print message

class nodepl_client(nodepl):

    def __init__(self, options = {}):
        self.options = options
        defaults = {
            'roles': {},
            'nodes': {},
            'groups': {},
            'public-key': self.home + '/.ssh/id_rsa.pub',
            'init-script-template': """
                nodepl={nodepl_path}
                sudo=

                if [[ $EUID -ne 0 ]]; then
                    if sudo -n true 2>/dev/null; then
                        echo "passwordless sudo detected"
                        sudo=sudo
                        nodepl="$sudo $nodepl"
                    else
                        echo "This script must be run as root"
                        echo "Enable passwordless sudo for this user? (Y/n)"
                        read x
                        if [[ $x != 'n' ]]; then
                            echo "Installing sudo..."
                            sudo cp /etc/sudoers /var/tmp/sudoers.bak
                            sudo cp /etc/sudoers /var/tmp/sudoers.new
                            echo "$USER ALL=(ALL) NOPASSWD: ALL # added by nodepl" | sudo tee -a /var/tmp/sudoers.new
                            sudo visudo -cf /var/tmp/sudoers.new
                            if [[ $? = 0 ]]; then
                                sudo cp /var/tmp/sudoers.new /etc/sudoers
                                sudo visudo -c
                            else
                                echo "Error in new config!"
                                exit 1
                            fi
                        else
                            exit 1
                        fi
                    fi
                fi

                echo "sudo is $sudo"
                echo "nodepl is $nodepl"

                if [[ ! -f ~/.ssh/id_rsa ]]; then
                    ssh-keygen;
                fi;

                echo '{public_key}' > ~/.ssh/authorized_keys
                $sudo chmod u=rw,o=,g= ~/.ssh/id_rsa.pub

                type python

                if [[ $? != 0 ]]; then
                    echo "Installing python"
                    $sudo apt-get install python || exit 1
                fi

                tmp="$(mktemp)"
                echo '{nodepl_script}' | base64 -d > "$tmp"

                $sudo cp "$tmp" {nodepl_path} || exit 1

                if [[ ! -f "{nodepl_path}" ]]; then
                    echo "{nodepl_path} not found"
                    exit 1
                fi

                $sudo chmod +x {nodepl_path} || exit 1

                $nodepl init test || exit 1

                export DEBIAN_FRONTEND=noninteractive

                if ! type rsyncinit_script_template &>/dev/null; then
                    $nodepl package install rsync
                fi;
            """
        }
        config_file = self.find_config('client')
        self.client = self.load_config(config_file, defaults, 'client-')
        self.nodepl_script = self.encode_script(sys.argv[0])
        self.public_key = self.load_file(self.client['public-key'])

    def load_file(self, filename):
        handle = open(filename, 'r')
        result = handle.read()
        handle.close()
        return result

    def encode_script(self, filename):
        handle = open(filename)
        result = base64.b64encode(handle.read())
        handle.close()
        return result

    def find_config(self, name):
        key = '-'
        if name + '-config' in self.options:
            return self.options[name + '-config']
        else:
            files = [
                self.home + '/.nodepl/nodepl-' + name + '.conf',
                '/etc/nodepl-' + name + '.conf'
            ]
            for filename in files:
                if os.path.isfile(filename):
                    return filename
        print 'Config file not found for: ' + name
        exit(1)

class nodepl_core(nodepl_client):

    def push(self):
        self.log_local('notice', 'collecting node information')
        nodes = []
        node_defaults = {
            'username': 'root'
        }
        for group_name in self.client['groups']:
            group = self.client['groups'][group_name]
            for node_name in group['nodes']:
                node = node_defaults.copy()
                node.update(group)
                if node_name in self.client['nodes']:
                    node.update(self.client['nodes'])
                nodes.append({
                    'name': node_name,
                    'node': node
                })
        self.log_local('notice', 'updating ' + str(len(nodes)) + ' nodes')
        for node in nodes:
            self.run_node(node['name'], node['node'])
        return True

    def run_node(self, node_name, node):
        host = 'host' in node and node['host'] or node_name
        ssh_host = node['username'] + '@' + host
        self.log_local('notice', 'sync node: ' + ssh_host + ' (' + node_name + ')')
        self.log_local('debug', '    roles: ' + ' '.join(node['roles']))
        packages = {}
        services = {}
        files = {}
        for role_name in node['roles']:
            role = self.client['roles'][role_name]
            if 'packages' in role:
                packages.update(role['packages'])
            if 'services' in role:
                services.update(role['services'])
            if 'files' in role:
                files.update(role['files'])
        remote_commands = []
        package_commands = []
        service_commands = []
        nodepl_path = self.array_get(node, 'nodepl-path', self.nodepl_path)
        remote_commands.append(self.client['init-script-template'].format(
            public_key = self.public_key,
            nodepl_script = self.nodepl_script,
            nodepl_path = nodepl_path
        ))
        remote_commands.append('$nodepl package upgrade')
        for name in packages:
            package = isinstance(packages[name], basestring) and {'status': packages[name]} or packages[name]
            self.log_local('notice', '        package: ' + name + ' ' + package['status'])
            package_commands.append('$nodepl package ' + package['status'] + ' ' + name)
        for name in services:
            service = isinstance(services[name], basestring) and {'status': services[name]} or services[name]
            self.log_local('notice', '        service: ' + name + ' ' + service['status'])
            service_commands.append('$nodepl service ' + service['status'] + ' ' + name)
        self.log_local('notice', '    execute remote commands')
        if not self.remote_shell(ssh_host, "\n".join(remote_commands + package_commands + service_commands)):
            return False
        remote_commands = []
        self.log_local('notice', '    syncing files...')
        for name in files:
            file_info = isinstance(files[name], basestring) and {'path': files[name]} or files[name]
            path = file_info['path']
            source = 'source' in file_info and file_info['source'] or path
            if os.path.isdir(source) and not source.endswith('/'):
                source += '/'
            options = [
                '-v',
                #'--progress',
            ]
            self.log_local('notice', '        file: ' + name + ' ' + path)
            self.log_local('notice', '        sync: ' + path + ' from ' + source)
            if 'delete' in file_info and file_info['delete']:
                options.append('--delete')
            if 'recursive' in file_info and file_info['recursive']:
                options.append('-a')
            if self.rsync(source, ssh_host + ':' + path, options):
                if 'on_change' in file_info and file_info['on_change']:
                    # TODO: run only if something changed...
                    remote_commands.append(file_info['on_change'])
        # make sure services are running if they depend on any changed files...
        self.log_local('notice', '    execute remote commands')
        if not self.remote_shell(ssh_host, "\n".join(remote_commands + service_commands)):
            return False
        self.log_local('notice', '    done')

    # ssh to one or multiple remotes
    def ssh(self):
        self.log_local('error', 'fix')

    # run a single command on one or more remotes
    def cmd(self):
        self.log_local('error', 'fix')

class nodepl_package(nodepl):
    command = ['apt-get', '-y']
    # '-o', 'Dpkg::Options::="--force-confdef"', '-o', 'Dpkg::Options::="--force-confold"'

    def has(self, package):
        return self.shell(['dpkg', '-s', package], silent=True)

    def install(self, package):
        if not self.has(package):
            self.log_notice('++ Installing package: ' + package)
            return self.shell(self.command + ['install', package])
        return None

    def remove(self, package):
        if self.has(package):
            self.log_warning('-- Removing package: ' + package)
            return self.shell(self.command + ['remove', package])
        return None

    def upgrade(self):
        self.log_notice('** Upgrading packages')
        return self.shell(self.command + ['update']) and self.shell(self.command + ['dist-upgrade'])

    def add_key(self, keyfile, id):
        #if(!sys_exec(['apt-key', 'list', '|', 'grep', id])):
        #    sys_exec(['wget', '-O/tmp/dotdeb.gpg', 'http://www.dotdeb.org/dotdeb.gpg', && apt-key add /tmp/dotdeb.gpg &&
        pass


class nodepl_service(nodepl):
    command = ['service']

    def status(self, service):
        return self.shell(self.command + [service, 'status'], silent=True)

    def is_running(self, service):
        return self.status(service)

    def is_installed(self, service):
        return self.status(service) or not 'unrecognized' in self.stderr

    def start(self, service):
        print self.command
        print service
        if self.is_installed(service) and not self.is_running(service):
            print ":P::: " + service + 'start'
            return self.shell(self.command + [service, 'start'])
        return None

    def stop(self, service):
        if self.is_installed(service) and self.is_running(service):
            return self.shell(self.command + [service, 'stop'])
        return None

    def reload(self, service):
        if self.is_installed(service) and self.is_running(service):
            return self.shell(self.command + [service, 'reload'])
        return None

class nodepl_deploy(nodepl_client):

    def __init__(self, options):
        nodepl_client.__init__(self, options)
        default_config = {
            'path': '/var/www',
            'storage': '/var/lib/nodepl/deploy',
            'user': 'deploy'
        }
        for node in self.client['nodes']:
            node = self.client['nodes'][node]
            config = 'deploy' in node and node['deploy'] or {}
            config.update(default_config)
            node['deploy'] = config
        self.detect_project()

    def detect_project(self):
        self.log_local('notice', 'detecting project')
        self.project_path = self.get_option('project-path', '.')
        if not os.path.isdir(self.project_path):
            self.log_local('error', 'project path does not exist')
            exit(1)
        if not os.path.isdir(self.project_path + '/.git'):
            self.log_local('error', 'project path is not a git project')
            exit(1)
        self.project_config_file = self.get_option('project-config', self.project_path + '/.nodepl-deploy.conf')
        self.project = {
            'name': os.path.basename(os.path.realpath(self.project_path)),
            'target': 'www',
            'cache-path': expanduser('~') + '/.nodepl/deploy-cache'
        }
        self.project = self.load_config(self.project_config_file, self.project, 'project-')
        if not os.path.isdir(self.project['cache-path']):
            os.makedirs(self.project['cache-path'])
        self.shell('git rev-parse --verify HEAD'.split(' '))
        self.project_version = self.stdout.split("\n")[0]
        self.cache_path = self.project['cache-path'] + '/' + self.project['name'] + '/' + self.project_version
        if not os.path.exists(self.cache_path):
            os.makedirs(self.cache_path)
        self.log_local('notice', '  name: ' + self.project['name'])
        self.log_local('notice', '  latest version: ' + self.project_version)

    def build(self, version = False):
        if version == False:
            version = self.project_version
        self.log_local('notice', 'build ' + version)
        if not 'nocache' in self.options and self.remote_version_exists(version):
            self.log_local('notice', 'version exists on server')
            return
        self.log_local('notice', 'building cache')
        subprocess.call(['git', 'checkout-index', '-a', '-f', '--prefix', self.cache_path + '/'])
        subprocess.call(['du', '-hs', self.cache_path])
        self.log_local('notice', 'cache complete')

    def get_nodes(self):
        if self.project['target'] in self.client['groups']:
            return self.client['groups'][self.project['target']]['nodes']
        return [self.project['target']]

    def run(self, version = False):
        nodes = self.get_nodes()
        self.log_local('notice', 'begin deployment to '+ self.project['target'])
        self.log_local('notice', '  affected nodes are: ' + ' '.join(nodes))
        self.build(version)
        self.sync(version)
        self.deploy(version)
        self.log_local('notice', 'done')

    # @todo Triggers (copy assets, db and other things)
    def sync(self, version):
        self.log_local('error', 'fix fix fix: sync(self, version):')
        # rsync self.cache_path remote_path + hash

    # @todo Sync deployment with other nodes
    def deploy(self, version):
        self.log_local('error', 'fix fix fix: deploy(self, version):')
        # symlink new version

    def status(self):
        nodes = self.get_nodes()
        self.log_local('notice', 'fetching deployment status from '+ self.project['target'])
        self.log_local('notice', '  affected nodes are: ' + ' '.join(nodes))
        if True:
            self.log_local('error', 'this project is not deployed on any known servers')
        self.log_local('notice', 'done')

    def log(self):
        nodes = self.get_nodes()
        self.log_local('notice', 'fetching deployment log from '+ self.project['target'])
        self.log_local('notice', '  affected nodes are: ' + ' '.join(nodes))
        self.log_local('notice', 'done')

    def remote_version_exists(self, target):
        return False

class nodepl_init(nodepl):

    def test(self):
        self.log_success('script is ready')

options = {}
args = []

i = 1
while i < len(sys.argv):
    if i + 1 < len(sys.argv) and sys.argv[i].startswith('--'):
        options[sys.argv[i][2:]] = sys.argv[i + 1]
        i = i + 1
    else:
        args.append(sys.argv[i])
    i = i + 1

if len(args) < 2:
    print 'nodepl <module> <method> [args] [--options]'
    exit(1)

name = globals()['nodepl_' + args[0]]
method = getattr(name(options), args[1])
result = method(*args[2:])

if result == False:
    exit(1)

exit(0)
